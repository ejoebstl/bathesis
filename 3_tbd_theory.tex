\section{Theoretic fundamentals}
While a very comprehensive theoretical model for incremental programs based on DDGs and memorization can be found in \cite{Acar2005thesis}, we have to adjust parts of the model to fit the TBD platform. The concept of a \textit{trace} is necessary as a fundamental approach for gathering information about an incremental program. The approach of \textit{trace distance} is important for the analysis of programs, since it can be used as a metric for the performance of the change propagation of a given incremental algorithm. 

\subsection{Execution Traces}

\label{sec:ddg_memo}
A trace is a theoretical construct which can be described as an ordered tree, whereas nodes represent function calls during the program execution \cite{Acar2005thesis}. While similar to the DDG, a trace tracks no data dependencies. A trace usually resembles the call tree of a program. 

\begin{definition}[General trace node equality]
Each node $v$ is uniquely described by a tag, consisting of

\begin{itemize}
\item the function being called, $fun(v)$
\item the arguments of the function call, $args(v)$
\item the values read in the body of the function, $reads(v)$
\item the values returned to the function from its callees, $returns(v)$
\item the weight of the function, $w(v)$, which is equal to its execution time.
\end{itemize}

Two nodes $v$ and $v'$ are equal, denoted $v \equiv v'$, if $fun(v) = fun(v')$, $args(v) = args(v')$, $reads(v) = reads(v')$ and $returns(v) = returns(v')$.
\end{definition}

\subsection{Trace distance}
Trace distance can basically be described as an edit distance between two execution traces \cite{Acar2005thesis} \cite{acar2004dynamizing}. 

To find the minimum trace distance of two traces $T$ and $T'$, the so called \textit{cognates} relation can be used. 

\begin{definition}[Cognates]
A set of cognates $C$ is a relation of two traces $T$ and $T'$ with the set of nodes $V$ and $V'$, so that

\begin{itemize}
\item $C \subset V \times V'$
\item for each $(v, v') \in V: v \equiv v'$ 
\item no node is paired with more than one node
\end{itemize}
\end{definition}
All nodes of both traces $T$ and $T'$ can be colored either blue, yellow or red. 
Nodes which have a cognate are colored blue. Nodes of $T$ without a cognate are colored yellow. Nodes of $T'$ without a cognate are colored red. 

The trace distance can now be calculated by summing up the weights of all yellow and red nodes. 

\begin{definition}[Trace distance]
The trace distance $\delta(T, T')$ between two traces $T$ and $T'$ is given by
\begin{align*}
  \delta(T, T') = \sum_{y \in Y} w(y) + \sum_{r \in R} w(r)
\end{align*}
whereas $Y$ denotes the set of all yellow vertices and $R$ is the set of all red vertices. 
\end{definition}

If the cognate relation $C$ is maximal, the intrinsic distance is minimal, denoted as $\delta^{min}$. Also, a maximal cognate relation can be found using a naive greedy algorithm \cite{Acar2005thesis} \cite{acar2004dynamizing}.

The minimal trace distance forms a lower bound for the duration of change propagation, since during change propagation all red vertices have to be deleted, and all yellow vertices have to be re-evaluated \cite{Acar2005thesis}.

\subsection{Traces in TBD}

While we can retain the definition of a trace, we have to adjust the definition of nodes and node equality for our purpose, so we can use it in the next section to construct an algorithm for trace distance calculation usable on the TBD platform. 

\subsubsection{TBD trace nodes}
As described in section \ref{sec:tbd}, TBD provides $read$, $mod$, $write$, $memo$ and $par$ methods to the developer. Instead of creating an execution trace out of all  functions in the program, we restrict ourselves to a trace consisting of only these functions. It should be noted, that, since we require each function to be side-effect free and deterministic, we could theoretically omit $write$ nodes in the DDG, since they directly depend on their corresponding parent nodes. However, including these nodes can provide useful insights during debugging. 

\begin{definition}[TBD Trace nodes]
Let each node in our execution trace represent a $read$, $mod$, $write$ $memo$ or $par$ function. We annotate each node with a tuple of the following values:
\begin{itemize}
\item the node type $t$, which can have the values $read$, $mod$, $write$, $memo$ or $par$
\item a node tag, a sequence of labels which has a different structure depending on the node type 
\end{itemize}
\end{definition}

Depending on the node type, we define the following node tags: 

\begin{definition}
Let the tag for $read$ nodes consist of $\mathbf{(a, fun)}$, whereas
\begin{itemize}
\item $a$ is the value of the modifiable being read
\item $fun$ is the reader function being called
\end{itemize}
\end{definition}

\begin{definition}
Let the tag for $mod$ nodes consist of $\mathbf{(fun)}$, whereas
\begin{itemize}
\item $d$ is the id of the destination generated by this call
\item $fun$ is the initializer function being called
\end{itemize}
\end{definition}

\begin{definition}
Let the tag for $write$ nodes consist of $\mathbf{(a, d)}$, whereas
\begin{itemize}
\item $a$ is the value being written
\item $d$ is the id of the destination where $a$ is being written to 
\end{itemize}
\end{definition}

\begin{definition}
Let the tag for $memo$ nodes consist of $\mathbf{((a_1, ..., a_n), fun)}$, whereas
\begin{itemize}
\item $(a_1, ..., a_n)$ is the list of values to memo match against
\item $fun$ is the function being called
\end{itemize}
\end{definition}

\begin{definition}
Let the tag for $par$ nodes consist of $\mathbf{(fun_1, fun_2)}$, whereas
\begin{itemize}
\item $fun_1$ is the first function being called
\item $fun_2$ is the second function being called
\end{itemize}
\end{definition}

\subsubsection{TBD trace node equality}
\label{sec:node_equality}
Given these definitions, we now re-define equality of nodes. 

\begin{definition}[Node equality]
Let a node $A$ and $B$ be equal, iff the node type of $A$, $t_a$, equals the node type of $B$, $t_b$, and the tag of $A$ equals the tag of $B$. 
\end{definition}
We only compare the the tag if the node type already matches. Therefore, we can simply compare each element in the tag of $A$ with it's counterpart in the tag of $B$. 

The tag can consist of objects, value types, modifiables or functions. For functions, showing equality is not solvable in general \cite{church1936note}. With the constraints of TBD programs, however, we are able to create a sufficient equality definition for our purpose.
\begin{definition}[Function execution equality for TBD traces]
\label{def:fun_equality}
A function execution $fun_a$ and a function execution $fun_b$ are equal, iff all of the following conditions apply: 
\begin{enumerate}
\item $fun_a$ and $fun_b$ refer to the same symbol in the source code. 
\item all arguments are equal.
\item all free variables bound from an outer scope are equal. 
\end{enumerate}
\end{definition}

The requirement for side-effect free and deterministic functions leads to the conclusion, that all sub calls to other functions, including any writes, are going to be equal if the function is invoked with the same parameters. We have to take care of free variables in the function, however, since they might influence the behavior of the program. An example would be a $read$ nested within another $read$, whereas the inner $read$ accesses the value provided by the outer read, which can be seen in listing \ref{code:simpleExample}. If the value of $mod1$ changes in the example the inner function performing the addition of $v1$ and $v2$ is not going to be equal anymore, therefore the $read$ node of the inner $read$ has changed, even the value of $mod2$ stays the same. 

For comparing values or objects inside the tag, function parameters or closed free variables we use \textit{deep equality}. Modifiables, however should be compared by reference equality. The reason for doing so is to ensure correctness even with complex types, for example like arrays, nested lists or objects. For modifiables, the change propagation algorithm takes care of changed values, and automatically calls all sub calls which are affected. The case where the modifiable itself was re-created forms an exception, where we would have to re-execute all reads which would access this modifiable. This leads to the following formal definition: 

\begin{definition}[Object equality for TBD traces]
A primitive value $p$ is equal to a primitive value $k$ iff $p$ and $k$ have the same type and the same value. 

A modifiable $x$ is equal to a modifiable $y$ iff $x$ and $y$ refer to the same object in memory.

An object $A$ with ordered properties $(a_1, ..., a_n)$ is equal to an object $B$ with ordered properties  $(b_1, ..., b_n)$ iff $A$ and $B$ have the same type and $a_i$ equals $b_i$ $\forall i \in[1, n]$. Properties of an object can be other objects, modifiables or primitives. 
\end{definition}

With these definition of trace node equality, we can keep the definition of $Cognates$ and $Trace Distance$ given in in section \ref{sec:ddg_memo}.

Figure \ref{tree:incrementListTrace} illustrates a trace of a TBD program. The program executed here is the example found in listing \ref{code:memoExample}. The input consists of a list of three elements, 1, 2 and 3 in this case. Values of the form $d.\alpha$ inside the tag denote dests or mods, whereas $\alpha$ is the unique key. Values of the form $f.\delta $ inside the tag denote anonymous functions, whereas $\delta $ is an automatically generated unique identifier. 

\begin{figure}
\centering
\begin{tikzpicture}[font=\sffamily,very thick,level/.style={sibling distance=30mm}]
\tikzstyle{every node}=[font=\small]
\node [root]{}
child {
  node [mod, label={350:(d.14,f.9)}]{}
  child {
    node [read, label={350:(ListNode,f.8)}]{}
    child {
      node [mod, label={350:(d.15,f.6)}]{}
      child {
        node [read, label={350:(1,f.5)}]{}
        child {
          node [write, label={350:(2,d.15)}]{}
        }
      }
    }
    child {
      node [memo, label={350:(f.7,(1, Mod(d.9)))}]{}
      child {
        node [mod, label={350:(d.16,f.9)}]{}
        child {
          node [read, label={350:(ListNode,f.8)}]{}
          child {
            node [mod, label={350:(d.17,f.6)}]{}
            child {
              node [read, label={350:(2,f.5)}]{}
              child {
                node [write, label={350:(3,d.17)}]{}
              }
            }
          }
          child {
            node [memo, label={350:(f.7,(1, Mod(d.11)))}]{}
            child {
              node [mod, label={350:(d.18,f.9)}]{}
              child {
                node [read, label={350:(ListNode,f.8)}]{}
                child {
                  node [mod, label={350:(d.19,f.6)}]{}
                  child {
                    node [read, label={350:(3,f.5)}]{}
                    child {
                      node [write, label={350:(4,d.19)}]{}
                    }
                  }
                }
                child {
                  node [memo, label={350:(f.7,(1, Mod(d.13)))}]{}
                  child {
                    node [mod, label={350:(d.20,f.9)}]{}
                    child {
                      node [read, label={350:(null,f.8)}]{}
                      child {
                        node [write, label={350:(null,d.20)}]{}
                      }
                    }
                  }
                }
                child {
                  node [write, label={350:(ListNode,d.18)}]{}
                }
              }
            }
          }
          child {
            node [write, label={350:(ListNode,d.16)}]{}
          }
        }
      }
    }
    child {
      node [write, label={350:(ListNode,d.14)}]{}
    }
  }
};
\end{tikzpicture}
\caption{Trace of a TBD program [Todo: Find more elegant solution for tags.]}
\label{tree:incrementListTrace}
\end{figure}

The leftmost subtrees correspond to creating a modifiable for the resulting value, reading the input value and writing the result. The central path holds all calls which recursively read the input and handle memorization. The rightmost and bottom $write$ calls write the resulting new list nodes.  

The edges in the trace illustrate control dependencies. However, by observing the keys of dests in the $mod$ and $write$ operations, data dependencies can be found. 
