\section{An intrinsic trace distance algorithm for TBD}
While \cite{Acar2005thesis} already outlines a greedy algorithm for calculating the intrinsic trace distance, there are details we have to take care of for accomplishing an implementation.

\subsection{Implementing node equality}
While equality of nodes is defined in section \ref{sec:node_equality}, it still remains open how a equality is implemented. For value types or objects we can use the $equals$ method provided by the Scala platform or define our own overload of $equals$, if needed.  

For testing anonymous functions passed to $read$, $memo$, $mod$, and $par$ for equality, we have to compare the the function itself, all parameters, all arguments, and all free variables bound from an outer scope, as described in definition \ref{def:fun_equality}. To accomplish this task, we can utilize the Scala macro API \cite{burmako2013scala}. Basically, the Scala macro API enables us to define small programs written in Scala, which are executed during compile time. From within these macros, we can access all information the compiler has and modify the abstract syntax tree (AST) of our program on the fly. 

To gather the necessary information for comparing anonymous functions during runtime, we replace the implementations of $read$, $memo$, $mod$ and $par$ with macros, which extract interesting information and create a tag from it. The macro generates code which calls the original function and passes the original parameters and the tag as arguments. 

During macro expansion, we can simply assign an unique ID to each function. This way, we can easily check whether to function tags refer to the same function. The arguments of the function are also well known for all methods provided by TBD, so they can be easily added to the tag. 

Finding free variables which are bound from an outer scope, however, is not straight-forward, because at the macro expansion step, the Scala compiler has no knowledge about whether a symbol is a function or a variable, or from where it is bound.

To extract only the correct symbols, we first create a list of all symbols which occur in the anonymous function $F$ and store them in a set $V = (v_1, ..., v_n)$. Then, for each $v_i$, $i \in[1..n]$, we iterate over all ancestors of $v_i$ in the AST of $F$. If we find a variable definition or parameter which defines a symbol with the same name as $v_i$, we know that $v_i$ is not bound from an outer scope, so we remove it from our list $V$.

Then, we iterate over all ancestors in the AST of the outermost enclosing scope of $F$. This scope is the class in which $F$ is defined in most cases. If we find an ancestor which defines a variable or parameter, we add the symbol of that variable to a set $D = (d_1, ..., d_m)$. Finally, we compute the set $U = (u_1, ..., u_k) = V \cap D$, whereas equality of elements in $V$ and $D$ is defined by equality of the symbol name. The set $U$ now contains only symbols, which are used in $F$, defined somewhere outside $F$ and are variables. 

Now, we generate code to add the name and value of each symbol $u_i$ to a Scala list, whereas the list is then added to the tag. The tag is passed to the original function, which adds it to the corresponding node in the DDG.  

By applying the described technique, we are now able to create a tag, which can be used to compare nodes which depend on anonymous functions for equality. 

\subsection{Implementing the intrinsic distance algorithm}
Given all nodes in two traces $T_1$ and $T_2$, including their tag, the trace distance can be computed like described in \cite{Acar2005thesis}.  

For a naive greedy algorithm, we create a tree- or hash set $S_1$, which holds all nodes from $T_1$. Then, we test for each node in $T_2$, if a node with an equal tag existed in $S_1$. If so, we remove the node from $S_1$.

When all nodes have been tested, the intrinsic trace distance is given by the size of the set $|S_1|$ plus the count of nodes from $T_2$ which were not contained in $S_1$. 
\subsection{Proof of correctness}
[The proof is not yet complete. An approach is to assume an optimal change propagation algorithm for TBD and then show that our distance algorithm leads to the same result]